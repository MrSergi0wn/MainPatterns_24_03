using System.Collections.Concurrent;
using System.Numerics;
using System.Reflection;
using SpaceBattle.Actions;
using SpaceBattle.Adapter;
using SpaceBattle.Commands.Simple;

namespace SpaceBattle.Ioc
{
    public class IoContainer : IResolvable
    {
        public ConcurrentDictionary<string, Scope> Scopes { get; } = new();
        public ThreadLocal<Scope> CurrentScope { get; } = new() { Value = new Scope("DefaultScope") };

        public T Resolve<T>(string key, params object[] args)
        {
            switch (key)
            {
                case "Object.SetPosition":
                    return (new SetObjectPositionCommand((IMovable)args[0], (Vector2)args[1]) is T setObjectPositionCommand
                        ? setObjectPositionCommand
                        : default)!;

                case "Object.GetVelocity":
                    return (((IMovable)args[0]).Velocity is T velocity
                        ? velocity
                        : default)!;

                case "Object.GetPosition":
                    return (((IMovable)args[0]).Position is T position
                        ? position
                        : default)!;

                case "AutoGeneratedMovableAdapter":
                    return ((TypeInfo)args[0]).Name switch
                    {
                        nameof(IMovable) => (new AutoGeneratedMovableAdapter((IMovable)args[1], this) is T adapter
                            ? adapter
                            : default)!,
                        _ => throw new InvalidOperationException()
                    };

                case "Scopes.New":
                    return (new ScopeRegisterCommand(Scopes, args[0].ToString()!) is T scopeRegisterCommand
                        ? scopeRegisterCommand
                        : default)!;

                case "Scopes.Current":
                    return (new ScopeCurrentSetCommand(this, Scopes, args[0].ToString()!) is T scopeCurrentSetCommand
                        ? scopeCurrentSetCommand
                        : default)!;

                case "IoC.Register":
                    return (new IocRegisterCommand(CurrentScope.Value?.Dependencies!,
                        (args[0] as string)!,
                        (args[1] as Func<object[], object>)!) is T iocRegisterCommand
                        ? iocRegisterCommand
                        : default)!;
            }

            if (CurrentScope.Value == null || key == null || !CurrentScope.Value.Dependencies.ContainsKey(key))
                throw new Exception($"Операции связанные с {key} не найдены!");

            var function = (Func<object[], object>)CurrentScope.Value.Dependencies[key];

            return (T)function.Invoke(args);
        }
    }
}